一、原生node
	1.第一个node程序：hello node
		打开终端  输入node  回车  console.log("hello world");
		hantao@:~$ node
		> console.log("hello world");
		hello world
	2.搭建一个服务器
		a.引入http模块
			var http = require("http");
		b.创建服务器
			var server = http.createServer(calback);
		c.监听端口
			server.listen(3000,hostname,callback);
		d.完整代码
			var http = require("http");
			var port = 3000;
			var hostname = "loaclhost";
			var server = http.createServer(function(req,res){
				res.statusCode = 200;
				res.setHeader("Content-Type","text/plain");
				res.end("hello world");
			});
			server.listen(port,hostname,function(){
				console.log("the server is runing in:"+hostname+":"+port);
			});
	3.npm使用
		a.npm简介
			npm是随同nodejs一起安装的包管理工具，能解决node代码部署的很多问题
			常见的使用场景有以下几种：
			。允许用户从NPM服务器下载别人编写的第三方包到本地使用。
			。允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。
			。允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。
			可以通过npm -v 来查看版本信息
			npm install npm -a 来更新npm
		b.使用npm安装模块
			$ npm install <Module Name>
			安装express：
			npm install express
			安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此
			在代码中只需要通过 require('express') 的方式就好，无需指定第三方包路径。
			var express = require("express");
		c.全局安装、本地安装
			npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，
			差别只是有没有-g而已，比如：
			npm install express -g//全局安装
			npm install express //本地安装
			$ npm ls -g//查看全局安装包
		d.使用 package.json
			package.json 位于模块的目录下，用于定义包的属性。
			package.json的常见属性
			name - 包名。
			version - 包的版本号。
			description - 包的描述。
			homepage - 包的官网 url 。
			author - 包的作者姓名。
			contributors - 包的其他贡献者姓名。
			dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖
			包安装在 node_module 目录下。
			repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。
			main - main 字段是一个模块ID，它是一个指向你程序的主要项目。就是说，
			如果你包的名字叫 express，然后用户安装它，然后require("express")。
			keywords - 关键字
		e.npm的常见，命令
			$ npm uninstall express//卸载模块
			$ npm update express//更新模块
			$ npm search express//查找模块
		f.使用淘宝 NPM 镜像
			$ npm install -g cnpm --registry=https://registry.npm.taobao.org
			$ cnpm install [name]
	4.Node.js REPL(交互式解释器)
		Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，
		类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，
		并接收系统的响应。
		Node 自带了交互式解释器，可以执行以下任务：
			读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。
			执行 - 执行输入的数据结构
			打印 - 输出结果
			循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。
			在终端输入node回车
			$ node
			> 
		a.简单的表达式
			$ node
			> 1 +4
			5
			> 5 / 2
			2.5
			> 3 * 6
			18
			> 4 - 1
			3
			> 1 + ( 2 * 3 ) - 4
			3
			>
		b.使用变量
			你可以将数据存储在变量中，并在你需要的使用它。
			变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来。
			使用 var 关键字的变量可以使用 console.log() 来输出变量。

			$ node
			> x = 10
			10
			> var y = 10
			undefined
			> x + y
			20
			> console.log("Hello World")
			Hello World
			undefined
			> console.log("www.runoob.com")
			www.runoob.com
			undefined
		c.多行表达式
			Node REPL 支持输入多行表达式，这就有点类似 JavaScript。
			接下来让我们来执行一个 do-while 循环：
			$ node
			> var x = 0
			undefined
			> do {
			... x++;
			... console.log("x: " + x);
			... } while ( x < 5 );
			x: 1
			x: 2
			x: 3
			x: 4
			x: 5
			undefined
			>
		d.下划线(_)变量
			你可以使用下划线(_)获取表达式的运算结果：
			$ node
			> var x = 10
			undefined
			> var y = 20
			undefined
			> x + y
			30
			> var sum = _
			undefined
			> console.log(sum)
			30
			undefined
			>
		e.REPL 命令
			ctrl + c - 退出当前终端。
			ctrl + c 按下两次 - 退出 Node REPL。
			ctrl + d - 退出 Node REPL.
			向上/向下 键 - 查看输入的历史命令
			tab 键 - 列出当前命令
			.help - 列出使用命令
			.break - 退出多行表达式
			.clear - 退出多行表达式
			.save filename - 保存当前的 Node REPL 会话到指定文件
			.load filename - 载入当前 Node REPL 会话的文件内容。
		f.退出REPL
			前面我们已经提到按下两次 ctrl + c 建就能退出 REPL:
			$ node
			>
			(^C again to quit)
			>
	5.nodejs的回调
		Node.js 异步编程的直接体现就是回调。
		异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。
		回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都
		支持回调函数。
		例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容
		作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大
		提高了 Node.js 的性能，可以处理大量的并发请求。
		a.阻塞示例：
			function fun1(){
				console.log("fun1");
			}
			function fun2(){
				console.log("fun2");
			}
			function fun3(){
				console.log("fun3");
			}
			fun1();
			fun2();
			fun3();
			输出结果：
			fun1
			fun2
			fun3
		b.非阻塞示例：
			function fun1(fun2){
				console.log("fun1");
				setTimeout(fun2,500);
			}
			function fun2(){
				console.log("fun2");
			}
			function fun3(){
				console.log("fun3");
			}
			fun1(fun2);
			fun3();
			输出结果：
			fun1
			fun3
			fun2
		因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，
		我们就需要写在回调函数内。
	6.node的模块系统：
		module对象是模块系统的核心，require和exports是它的两个属性，exports是模块的
		公开接口，require是模块的请求接口。在node中一个node.js文件就是一个模块。
		a.创建模块
			1）首先创建一个main.js,代码如下：
				var hello = require("./hello");
				hello.world();
			2）创建一个hello.js,代码如下：
				exports.world = function(){
					console.log("hello world");
				};
			3）$ node main.js 会输出hello world
		b.代码分析：
			main.js:require()函数是加载模块，./代表同级目录，hello：代表hello.js
			js文件可以省略后缀。
			hello.js:exports.world是将world函数暴落给模块系统。
		c.为一个对象创建模块
			我们在创建一个sayhello.js,代码：
			funtion hello(){
				var name = "";
				this.setnaem = function(sname){
					this.name  = sname;
				};
				this.sayhello = function(){
					console.log("hello "+this.name);
				};
				module.exports = hello;
			
			}
			main.js增加代码：
				var say = require("./sayhello");
				var sayhello = new say();
				sayhello.setname("hantao");
				sayhello.sayhello();
		
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
